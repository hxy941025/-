### let var const

主要区别：

- 块级作用域
- 不存在变量提升
  - 并非真的不会提升，只是在声明以前不可用，即暂时性死区TDZ
- 暂时性死区
  - 会导致typeof变的会报错，在TDZ里typeof报错ReferenceError
- 不可重复声明
- let、const声明的全局变量不会挂到window下面

const注意点

- const 声明之后必须马上赋值，否则会报错
- const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改
- 如果想完全冻结对象，使用Object.freeze(obj)，则属性也无更改

块级作用域与函数声明

- ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明
- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用
  - 以上只对支持ES6的浏览器有用，如果不支持，还是将函数声明当做var提升
- 鉴于以上问题，块级作用域函数声明容易出bug，所以**在块级作用域声明函数，最好使用匿名函数的形式**：**let** a = **function** () {}，这样会使函数作用域比较清晰

---

### 解构赋值

数组解构赋值：左边加[ ]

- let [foo, [[bar], baz]] = [1, [[2], 3]]   // 123
- let [x, , y] = [1, 2, 3]   // 1 3
- let [head, ...tail] = [1, 2, 3, 4]  // 1 [2,3,4]
- 默认值  let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
- 右侧为不可遍历结构则均报错
- 解构不成功，变量值为undefined

对象解构赋值

- let { foo, bar } = { foo: 'aaa', bar: 'bbb' }   // foo  "aaa"  bar  "bbb"
- let { foo: baz } = { foo: 'aaa', bar: 'bbb' }  // baz  "aaa" foo // error: foo is not defined
  - `foo`是匹配的模式，`baz`才是变量，赋值的是变量，模式只是用来匹配的
- 嵌套结构的对象一样可以，按照对象的嵌套模式解构即可
- 对已经声明过的变量进行解构赋值，需要将整个赋值表达式用（）括起来
- 默认值  var {x: y = 3} = {x: 5}  // y 5  x是模式，y是变量被赋值   
- 解构不成功，变量值为undefined

字符串解构赋值

- 字符串被当做类数组对象解构 const [a, b, c, d, e] = 'hello'

数值和布尔值的解构赋值

- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
  - let {toString: s} = 123  s === Number.prototype.toString // true
- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错

函数参数的解构赋值

- [[1, 2], [3, 4]].map(([a, b]) => a + b);   // [ 3, 7 ]

- ```javascript
  // 参数默认值情况
  function move({x = 0, y = 0} = {}) {
    return [x, y];
  }
  
  move({x: 3, y: 8}); // [3, 8]
  move({x: 3}); // [3, 0]
  move({}); // [0, 0]
  move(); // [0, 0]
  
  // 变量默认值情况
  function move({x, y} = { x: 0, y: 0 }) {
    return [x, y];
  }
  
  move({x: 3, y: 8}); // [3, 8]
  move({x: 3}); // [3, undefined]
  move({}); // [undefined, undefined]
  move(); // [0, 0]
  ```

-  区别总结：参数默认值情况是函数参数有默认值，所以不给也有值；而对象默认值情况是对象有默认值，如果赋值空对象即改变了它的默认对象，参数变成undefined

用途

- **交换变量的值**：不需要第三者[x, y] = [y, x]
- **从函数返回多个值**：返回对象或者数组，然后接受返回值解构
- **函数参数的定义**：解构赋值可以方便地将一组参数与变量名对应起来
- **提取 JSON 数据**：解构赋值对提取 JSON 对象中的数据
- **函数参数的默认值**
- **遍历 Map 结构**：for (let [key, value] of map)  直接取键值
- **输入模块的指定方法**：从模块中导出部分方法，类似对象的解构

### 字符串、正则、数值扩展

字符串

- 模板字符串 `foo ${变量名、函数调用} bar`
- **includes()**：返回布尔值，表示是否找到了参数字符串
- **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部
- **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部
- **repeat()**：重复，'na'.repeat(3) // 'nanana'，参数是 0 到-1 之间的小数，则等同于 0
- **padStart()**：补全头部，'x'.padStart(4, 'ab') // 'abax'，默认用空格补
- **padEnd()**：补全尾部：'x'.padEnd(4, 'ab') // 'xaba'，默认用空格补
- **trimStart()**：消除字符串头部的空格，返回新字符串，不修改
- **trimEnd()**：消除尾部的空格，返回新字符串，不修改
- **matchAll()**：方法返回一个正则表达式在当前字符串的所有匹配

正则

- ES6允许RegExp构造函数第一个参数是正则对象，第二个参数指定修饰符
- “先行断言”：x只有在y前面才匹配，必须写成/x(?=y)/
- “先行否定断言”：x只有不在y前面才匹配，必须写成/x(?!y)/
- “后行断言”：x只有在y后面才匹配，必须写成/(?<=y)x/
- “后行否定断言”：x只有不在y后面才匹配，必须写成/(?<!y)x/
- 具名组匹配：
  - 非具名：const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;  以数组index取结果
  - 具名：const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;  以属性名取值
- y修饰符：也是全局匹配，与g的区别在于确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义
- matchAll()：可以一次取出全局匹配结果数组，不需要通过循环操作

数值

- Number.isFinite()：检查一个数值是否为有限的（finite），即不是`Infinity`，非数值直接false
- Number.isNaN()：用来检查一个值是否为`NaN`，非数值直接false
  - 传统的全局方法`isFinite()`和`isNaN()`会对非数值先进行类型转换
- Number.parseInt、Number.parseFloat：跟全局方法parseInt一样，只是减少全局方法使语言逐步模块化
- Number.isInteger()：用来判断一个数值是否为整数
- Number.EPSILON：极小常量，表示 1 与大于 1 的最小浮点数之间的差
- Number.isSafeInteger()：安全整数，范围在`-2^53`到`2^53`之间（不含两个端点）
- Math.trunc：用于去除一个数的小数部分
- Math.sign：用来判断一个数到底是正数（返回+1）、负数（-1）、还是零（0）、其他值（NaN）
- Math.cbrt：用于计算一个数的立方根
- Math.hypot：方法返回所有参数的平方和的平方根
- `**`：指数运算，a ** b = a的b次方
- BigInt：第八种数据类型，可表示2^53以外

### 函数、数组、对象扩展

函数

- 参数默认值

  - 使用参数默认值时，函数不能有同名参数
  - 与解构赋值共同使用
  - 通常给参数默认值的都是尾参数，否则不能省略传参

- 函数length属性：返回指定了默认值的参数之前的形参个数

- 作用域：设置参数默认值后，参数会有个单独的作用域

  ```javascript
  var x = 1;
  function f(x, y = x) {
    console.log(y);
  }
  f(2) // 2
  
  let x = 1;
  function f(y = x) {
    let x = 2;
    console.log(y);
  }
  f() // 1
  ```

- rest参数：扩展运算符获取多余参数，形式为`...变量名`

- name属性：返回函数名，ES5匿名函数名为空，ES6为f

- 箭头函数，不适用定义对象方法、需要动态this的时候

  - 嵌套箭头函数：前一个函数的输出是后一个函数的输入

- 尾调用优化：在尾部调用即可不需要保存外层函数的调用栈

  - 尾递归：尾部递归，不存在栈溢出错误

    ```javascript
    // 尾递归优化版 斐波那契数列
    function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
      if( n <= 1 ) {return ac2};
      return Fibonacci2 (n - 1, ac2, ac1 + ac2);
    }
    ```

- ES6的尾调用优化只能在严格模式下开启，但是arguments、caller参数会失效
- 函数实例的`toString()`改写，以前只能返回代码，省略注释空格，现在会返回一样的原始代码

数组

- 扩展运算符
  - 复制数组：[...a2] = a1、a2 = [...a1]， = a1.concat() = a1.slice()
  - 合并数组：[...arr1, ...arr2, ...arr3] = arr1.concat(arr2, arr3)
  - 解构赋值：获取剩余参数，形成数组，只能放在最后
  - 字符串转数组：[...'hello'] = 'hello'.split("")
  - 任何Iterator接口的均可使用扩展运算符转成真正的数组，如Map、Set
- `Array.from`：用于将两类对象转为真正的数组
- `Array.of`：用于将一组值，转换为数组
- copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置，具体见数组API
- find()和findIndex()：用于找出第一个符合条件的数组成员、返回第一个成员位置
- fill：使用给定值，填充一个数组
- entries()：返回数组键值对
- keys()：返回数组键名
- values()：返回数组里键值
- includes()：方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似
- flat()：数组扁平化，传参为几就扁平化几层，默认值1层，小于等于0则不拉
- flatMap()：对原数组的每个成员先map，再执行flat，只能展开一层
- 数组的空位：Array(3) // [, , ,]，空位并不是undefined，空位是没有任何值

对象

- 属性简写，ES6允许大括号里直接写入变量和函数作为对象的属性和方法

- 属性名表达式：属性名可以['a' + 'b'] 这种表示

- 方法的name属性：即函数的name

- 属性的可枚举性和遍历：

| 方法                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| For in                       | 遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）         |
| Object.keys                  | 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 |
| Object.getOwnPropertyNames   | 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 |
| Object.getOwnPropertySymbols | 返回一个数组，包含对象自身的所有 Symbol 属性的键名           |
| Reflect.ownKeys              | 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 |

- super关键字：this总是指向函数所在的当前对象，super指向当前对象的原型，即proto
- 对象扩展运算符：基本同数组，但是如果右边是null、undefined，则报错
- 链判断运算符：`message?.body?.user?.firstName || 'default'`，左侧对象为null或者undefined时，直接不再往下运算返回undefined
  - 短路机制：左侧为null或者undefined后，右侧不再继续
  - 括号的影响： (a?.b).c = (a == null ? undefined : a.b).c，对外部无影响
- Null判断符?？：headerText ?? 'Hello, world!'，只有左侧为null和undefined右边才会生效，false，0不会触发
- Object.is()：比===更严格，解决了+0 = - 0、NaN不等于自身的bug
- Object.assign()：用于合并对象，将多个对象的属性合并成一个对象，如果有重复则后者覆盖前者
  - 第一个参数为目标对象，后面均为源对象
  - 首参数非对象先转成对象，无法转则跳过，非首参的，不能转化对象直接报错（null、undefined）
- 




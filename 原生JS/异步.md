### 进程和线程

- 根本区别：进程是资源分配的基本单位，线程是CPU调度的基本单位
- 开销方面：每个进程都有独立的代码和数据空间（上下文），**进程之间切换开销大**；同一进程下的不同线程间数据共享很容易，每个线程都有自己独立的运行栈和程序计数器（PC），**线程之间切换的开销小**
- 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）（时分复用）
- 内存分配：系统为每个进程分配不同的内存空间；而线程所使用的资源来自于进程，线程组之间只能共享资源
- 包含关系：线程是进程的一部分，一个线程只属于一个进程，而一个进程可以有多个且至少有一个线程

做个简单的比喻：进程=火车，线程=车厢，线程只能在进程下运行， 一个线程挂了将导致整个进程挂掉

### JS单线程

JS为单线程语言，原因：避免DOM渲染冲突，JS与DOM渲染共享线程

- JS执行时DOM渲染会停止，避免两段JS同时操作DOM时起冲突
- 节省内存，节约上下文切换时间

单线程意味着所有任务需要排队，前一个任务结束才会执行后一个任务，如果前一个任务耗时很长，后一个任务就被阻塞

- 同步任务：在主线程上排队执行的任务，只有前一个执行完后一个才能执行
- 异步任务：不进入主线程、而进入任务队列的任务，只有任务队列通知主线程某个异步任务可以执行了，才会进入主线程执行

### 执行栈

- 一个存储函数调用的栈结构，遵循先进后出的原则
- 调用函数时逐层将函数推入栈，遵循FILO，返回结果时逐层推出
- 当使用递归时，由于栈可存放的函数是有限制的，一旦存放过多而没得到释放就会爆栈

### 事件循环 Event Loop

JS通过事件循环来实现异步，即JS执行机制

![img](https://images2018.cnblogs.com/blog/1424035/201807/1424035-20180717203930248-574135681.png)

JS中遇到同步任务和异步任务会分别进入不同处理流程

- 同步任务进入主线程，异步任务进入Event Table（事件表），当事件表中异步任务完成后会在Event Queue（事件队列）中注册回调函数
- 主线程任务全部执行完后，才会完成Event Queue中的任务
- JS解析器会不断检查主线程执行栈是否为空，然后重复上一步

JS中异步任务又分为 **微任务**（microtask） 和 **宏任务**（macrotask）

- macro-task(宏任务)：包括整体代码script，setTimeout，setInterval

- micro-task(微任务)：Promise，process.nextTick（node独有）

  ![image-20200731152455067](/Users/hxy_nuc/Library/Application Support/typora-user-images/image-20200731152455067.png)

Event Loop整体执行步骤

- 执行完主执行线程中的任务
- 取出Microtask Queue中任务执行直到清空
- 如果需要渲染，则进行页面渲染
- 取出Macrotask Queue中**一个**任务执行
- 取出Microtask Queue中任务执行直到清空
- 重复4和5

在浏览器页面中可以认为初始执行线程中没有代码，每一个script标签中的代码是一个独立的task，即会执行完前面的script中创建的microtask再执行后面的script中的同步代码

**宏任务每执行完一个，就一次执行完事件队列中的微任务**

```javascript
while (true) {
  宏任务队列.shift()
  微任务队列全部任务()
}
```



### Node事件循环

![Node.js](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100803.png)

```javascript
（1）V8引擎解析JavaScript脚本。

（2）解析后的代码，调用Node API。

（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。

（4）V8引擎再将结果返回给用户。
```

Node中大致的事件循环顺序

在node中事件**每一轮**循环按照**顺序**分为6个阶段，来自libuv的实现：

- timers:执行定时器队列回调  setTimeout() setInterval()
- I/O callbacks:执行几乎所有回调，不包括 close 事件，定时器，和setImmediate()回调
- idle，prepare：可忽略
- poll：等待新的I/O事件，node在一些特殊情况下会阻塞在这里
- check：执行setImmediate的回调
- close callbacks：关闭所有的closing handles，一些onclose事件

##### 执行机制

**队列**：浏览器和node共有的microtask和node独有的`process.nextTick`，即Microtask Queue和NextTick Queue；及上述几个Timers Queue、I/O Queue、Check Queue、Close Queue

Node中的新增的于任务队列相关的方法，一个头一个尾

- **process.nextTick**方法可以在**当前"执行栈"的尾部**----**下一次Event Loop（主线程读取"任务队列"）之前-**---触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前（微）
- **setImmediate**方法则是在**当前"任务队列"的尾部添加事件**，也就是说，它指定的任务总是在**下一次Event Loop时执行**（宏）
- 区别：多个process.nextTick语句总是在当前"执行栈"一次执行完，多个setImmediate可能则需要多次loop才能执行完

```javascript
while (true) {
  loop.forEach((阶段) => {
    阶段全部任务()
    nextTick全部任务()
    microTask全部任务()
  })
  loop = loop.next
}
```

循环之前：

- 同步任务
- 发出异步请求
- 规划定时器生效的时间
- 执行`process.nextTick()`

开始循环：

按照我们的循环的6个阶段依次执行，每次拿出当前阶段中的全部任务执行，清空NextTick Queue，清空Microtask Queue。再执行下一阶段，全部6个阶段执行完毕后，进入下轮循环。即：

- 清空当前循环内的Timers Queue，清空NextTick Queue，清空Microtask Queue。
- 清空当前循环内的I/O Queue，清空NextTick Queue，清空Microtask Queue。
- 清空当前循环内的Check Queu，清空NextTick Queue，清空Microtask Queue。
- 清空当前循环内的Close Queu，清空NextTick Queue，清空Microtask Queue。
- 进入下轮循环。

可以看出，`nextTick`优先级比`promise`等microtask高。`setTimeout`和`setInterval`优先级比`setImmediate`高。（正如前述，`nextTick`在执行栈尾部即任务队列前执行，`setImmediate`在当前任务队列尾部）

#### 测试用例

```javascript
function sleep(time) {
  let startTime = new Date()
  while (new Date() - startTime < time) {}
  console.log('1s over')
}
setTimeout(() => {
  console.log('setTimeout - 1')
  setTimeout(() => {
      console.log('setTimeout - 1 - 1')
      sleep(1000)
  })
  new Promise(resolve => resolve()).then(() => {
      console.log('setTimeout - 1 - then')
      new Promise(resolve => resolve()).then(() => {
          console.log('setTimeout - 1 - then - then')
      })
  })
  sleep(1000)
})

setTimeout(() => {
  console.log('setTimeout - 2')
  setTimeout(() => {
      console.log('setTimeout - 2 - 1')
      sleep(1000)
  })
  new Promise(resolve => resolve()).then(() => {
      console.log('setTimeout - 2 - then')
      new Promise(resolve => resolve()).then(() => {
          console.log('setTimeout - 2 - then - then')
      })
  })
  sleep(1000)
})
```

浏览器输出

```javascript
setTimeout - 1 //1为单个task
1s over
setTimeout - 1 - then
setTimeout - 1 - then - then 
setTimeout - 2 //2为单个task
1s over
setTimeout - 2 - then
setTimeout - 2 - then - then
setTimeout - 1 - 1
1s over
setTimeout - 2 - 1
1s over
```

node输出

```javascript
setTimeout - 1 
1s over
setTimeout - 2 //1、2为单阶段task
1s over
setTimeout - 1 - then
setTimeout - 2 - then
setTimeout - 1 - then - then
setTimeout - 2 - then - then
setTimeout - 1 - 1
1s over
setTimeout - 2 - 1
1s over
```

浏览器执行流程

```javascript
<!--执行完主执行线程中的任务。-->
<!--取出Microtask Queue中任务执行直到清空。-->
<!--取出Macrotask Queue中一个任务执行。-->
<!--取出Microtask Queue中任务执行直到清空。-->
<!--重复3和4。-->
以 IQ 代指微任务队列，AQ 代指宏任务队列
1. 执行完主线程中任务：主执行线程执行完毕，setTimeout-1、setTimeout-2 进入等待
2. 清空 IQ：此时 IQ 中无任务
2. 执行 AQ 中一个任务： setTimeout-1 到时间后进入 AQ 中，被执行，执行过程中 setTimeout-1-1 进入等待状态，setTimeout-1-then 直接进入 IQ 队列，由于 setTimeout-1 中有 1s 等待，此时 setTimeout-2 肯定已经进入 AQ，setTimeout-1-1 也随后进入 AQ，此时结束状态为 IQ: [setTimeout-1-then]，AQ: [setTimeout-2, setTimeout-1-1]
3. 清空 IQ: 此时 IQ 中有 setTimeout-1-then，执行 setTimeout-1-then，执行过程中，setTimout-1-then-then 直接被加入 IQ，所以 IQ 没清空，所以继续执行 setTimout-1-then-then，IQ 被清空，此时结束状态为 IQ: [], AQ:  [setTimeout-2, setTimeout-1-1]
4. 执行 AQ 中一个任务：即执行 setTimeout-2
5. 清空 IQ: 这一步与 3 相似，所以输出 setTimeout-2-then、setTimeout-2-then-then，IQ 清空，此时结束状态为 IQ: [], AQ: [setTimeout-1-1, setTimeout-2-1]
6. 执行 AQ 中一个任务：即 setTimeout-1-1
7. 清空 IQ: 本身就为空
8. 执行 AQ 中一个任务：即 setTimeout-2-1
```

参考文章：https://juejin.im/post/6844903574560833550#heading-12

---

### 回调地狱

由于JS为单线程，想按照顺序执行异步只能通过异步嵌套完成，即回调函数里嵌套回调，层层回调的嵌套就形成了回调地狱

回调地狱的根本问题就是：

- 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
- 嵌套函数一多，就很难处理错误

---

### Promise

Promise可解决回调地狱问题，Promise为构造函数，需要通过new实例化

`Promise`对象有以下两个特点

- 对象的状态不受外界影响，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败），只有异步操作的结果可以决定状态，其他操作无法改变
- 一旦状态改变，就不会再变，任何时候都可以得到这个结果，只有pending->resolve和pending->reject两种情况

#### 基本用法

Promise构造函数接收一个函数作为参数，该函数的两个参数分别为resolve和reject，分别为Promise从pending到fulfilled后执行、从pending到rejected后执行，将异步执行结果或报错作为参数传递出去，传参会被then接收

then方法可以接受两个回调函数作为参数，即(resolve的回调，reject的回调)，第二个参数可以不写

```javascript
// 创建promise实例
const promise = new Promise(function(resolve, reject){
  //...
  if("success"){
    resolve(success)
  }else{
    reject(error)
  }
})
// 使用
promise.then(function(success){
  console.log(success)
}, function(error){
  console.log(error)
})
```

Promise新建后会立即执行，即new Promise后，其中同步代码会直接输出

##### Eg：异步加载图片

```javascript
function loadImageAsync(url){
  return new Promise(function(resolve, reject){
    const img = new Image()
    // 加载完后触发成功
    img.onload = function(){
      resolve(img);
    }
    // 无法加载图像时触发
    img.inerror = function(){
      reject(new Error("fail"))
    }
    img.src = url
  })
}
```

##### Eg：Promise封装Ajax

```javascript
// 封装一个ajax，返回封装好的promise对象
const promiseAjax = function(url){
  const promise = new Promise(function(resolve, reject){
    // 创建xhr对象
    const xhr = new XMLHttpRequest()
    // 设置onreadystatechange事件处理程序,以下以xhr代替this,更稳
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4){
        xhr.status === 200? resolve(xhr.response): reject(new Error(this.statusText))
      }
    }
    // open、send
    xhr.open("GET", url)
    xhr.send()
  })
  return promise
}
// 使用示例
promiseAjax("/test").then(function(res){
  console.log("success" + res)
}, function(err){
  console.error("fail" + err)
})
```

reject函数的参数通常是Error对象的实例，表示抛出的错误

resolve函数的参数除了正常的值以外还可以是Promise实例

```javascript
const p1 = new Promise(function (resolve, reject) {
  // ...
});

const p2 = new Promise(function (resolve, reject) {
  // ...
  resolve(p1);
})
// 上面情况时p1的状态会直接传给p2，即p1决定了p2状态，p2自身状态无效，p1状态改变时，p2的回调函数会立即执行
```

调用`resolve`或`reject`并不会终结 Promise 的参数函数的执行，但一般推荐直接return resolve和reject


### 变量

- 基础类型：存储的为值，占用大小固定，因此保存在栈中
  - 栈是自动分配固定大小的内存空间，并由系统自动释放
- 引用类型：存储的为指向该对象的指针，复制的时候为指针而非值，保存在堆中
  - 堆是动态分配内存，内存大小不一，也不会自动释放

### 执行环境及作用域

- **全局执行环境**是最外围的执行环境
- 每个函数都有自己的**执行环境**。当执行流入一个函数时，函数的环境就会被推入一个环境栈中，执行完毕后推出
- 当代码在一个环境中执行时，会创建变量对象的一个**作用域链**。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问
- 作用域的前端始终是当前执行的代码所在环境的变量对象，末端是全局执行环境

#### 作用域 Scope

- ES5中只有全局作用域和函数作用域

#### 全局作用域 Global Scope

- 不在任何函数内定义的变量就具有全局作用域
- JS默认全局对象window，全局作用域的变量会自动绑定到window上
- NodeJs全局对象global，且nodejs中每个js文件就是独立完整的作用域（module模块），因此其中var声明的变量即为当前.js文件中的局部变量
  - global全局对象是独立于所有.js之上的，想在文件中将对象绑定到global上，直接x=1即可

#### 局部作用域 Local Scope

- 

声明变量

- 使用var声明变量，会存在变量提升（自动提升到当前作用域最顶层声明）

### 垃圾收集

内存的生命周期

- 内存分配：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值
- 内存使用：然后在函数中使用这些变量，直至函数执行结束
- 内存回收：此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用

标记清除

- JavaScript 中最常用的垃圾收集方式是 **标记清除**（mark-and-sweep）
- 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”，而当变量离开环境时，则将其标记为“离开环境”

引用计数

- 另一种不太常见的垃圾收集策略叫做 **引用计数**（reference counting）
- 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数+1
- 如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数-1
- 当这个值的引用次数变成0时就可以将其占用的内存空间回收回来

---


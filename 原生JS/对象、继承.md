

### 对象

对象属性：数据属性、访问属性

- [[**configurable**]]：表示该属性能否删除或修改，默认true
- [[**enumerable**]]：表示该属性能否通过for in枚举，默认true
- [[**writable**]]：表示该属性能都被赋值运算修改值，默认true
- [[**value**]]：表示该属性的数值，默认undefined
- 
- **configurable**、**enumerable**同时也是访问器属性
- **get**：访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 `this` 对象，默认undefined
- **set**：当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 `this` 对象，默认undefined

####  **Object.defineProperty()**

- ```javascript
  Object.defineProperty(obj, prop, descriptor)
  obj: 要定义属性的对象
  prop: 要定义修改的属性的名称或symbol
  descriptor: 要定义或修改的属性描述符
  ```

- 该方法可直接在一个对象上定义一个新属性，或者修改一个对象的现有属性并返回此对象

- 修改三个数据属性时，都默认false，修改访问属性时，都默认undefined

---

### 创建对象

#### 工厂模式

```javascript
// 像工厂组装一样，从创建对象开始逐个对属性赋值，组装完成后返回
function createPerson(name, age){
  var o = new Object()
  o.name = name;
  o.age = age
  o.sayName = function(){ alert(this.name) }
  return o
}
let person = createPerson("Ace", 21)
```

#### 构造函数模式

```javascript
// 构造函数，主要利用new
function Person(name, age){
  this.name = name;
  this.age = age;
  this.sayName = function(){ alert(this.name) }
}
let person = new Person("Ace", 21)
```

##### new操作符简单实现

- 创建一个新对象
- 将构造函数的作用域赋给新对象（链接到原型）
- 执行构造函数中的代码（为这个新对象添加属性，绑定this）
- 返回新对象

```javascript
let person = myNew(Preson, name, age)
function myNew{
  let obj = {}
  obj.__proto__ = myFn.prototype
  let argsArr = [].slice.call(arguments, 1) //去除构造函数，获取其他参数
  let res = myFn.apply(obj, argsArr)
  return typeof res === 'object'? res: obj
}
```

#### 原型模式

```javascript
// JS中每个函数都有一个prototype（原型）属性。这个属性是一个指针，指向一个对象，即原型对象
function Person() {}
// 此处重写了整个prototype，会导致constructor失去指向Person
Person.prototype = {
  constructor: Person,
  name = "Ace",
  age = 21,
  sayName = function() { alert(this.name) }
}
let person = new Person()
```

每当创建一个新函数，该函数会自动创建一个prototype属性，这个属性指向函数的原型对象

在默认情况下，所有原型对象都会获得一个constructor（构造函数）属性， 这个属性包含一个执行prototype属性所在函数的指针

每当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（`__proto__`），指向构造函数的原型对象

![image-20200727000729191](/Users/hxy_nuc/Library/Application Support/typora-user-images/image-20200727000729191.png)

检测原型关系

- Person.prototype.isPrototypeOf(preson)===true
- Object.getPrototypeOf(person) === Person.prototype

当为对象实例添加属性时，会屏蔽掉原型对象上的同名属性，置null也不能恢复原型连接，只能delete删除才行

检测属性是存在实例本身还是原型上

- person.hasOwnProperty("name")：只有该属性存在于实例上才返回true
- hasPrototypeProperty(person, "name")：存在原型上，则返回true
- 原型上属性可以通过for in 遍历到（通过hasOwnProperty过滤）
- 获取实例属性：Object.keys()，不会搜到原型链上去
- 获取所有实例属性，包括不可枚举的：Object.getOwnPropertyNames()

原型的动态性：时刻谨记JS中对象的性质，当重写后即切断了之前的联系

#### 组合使用构造函数模式和原型模式

```javascript
//使用构造函数定义实例属性，使用原型模式定义实例方法和共享的属性
function Person(name, age){
  this.name = name
  this.age = age
}
Person.prototype.sayName = function() { alert(this.name) }
```

#### 动态原型模式

```javascript
// 将信息封装在构造函数中，没什么区别，就是封装起来
function Person(name, age){
  this.name = name
  this.age = age
  if(typeof this.sayName != 'function'){
    Person.prototype.sayName = function(){ alert(this.name) }
  }
}
```

#### 寄生构造函数模式

```javascript
// 基本思想是创建一个函数，仅仅用来封装创建对象的代码
// 在函数里新建对象绑定属性后返回新对象
function Person(name, age){
  let o = new Object()
  o.name = this.name
  o.age = this.age
  o.sayName = function(){
    alert(this.name)
  }
  return o
}
```

#### 稳妥构造函数模式

类似寄生构造函数模式，创建的对象与构造函数之间也无联系

#### 几种创建方式对比

| 创建方式               | 优缺点                                                   |
| ---------------------- | -------------------------------------------------------- |
| 工厂模式               | 简化创造对象，但没能解决对象识别问题（不知道对象类型）   |
| 构造函数模式           | 可检测类型，但每次实例化都会创建新的方法，没复用         |
| 原型模式               | 可共享所有属性及方法，但共享引用类型的变量会导致互相影响 |
| 组合构造函数和原型模式 | 较为推荐                                                 |
| 动态原型模式           | 不能使用字面量方式重写原型，会切断联系                   |
| 寄生构造函数模式       | 由于创建了新对象，跟原型之前没联系                       |

---

### 继承

#### 原型链

JS中实现继承主要依靠原型链继承

JS中每个函数都有一个原型对象prototype，原型对象包含一个指向构造函数的指针constructor

每个实例都包含一个指向原型对象的指针，`__proto__`

因此将子类的原型对象指向父类实例，即可通过子类实例.`__proto__`.`__proto__`来访问父类原型对象

```javascript
// 实现原型链基本模式
function superType(){
  this.property = true
}
superType.prototype.getSuperVal = function(){
  return this.property
}

function subType(){
  this.subproperty = false
}
// 核心步骤，将父类实例赋值给子类原型对象，连接原型链
subType.prototype = new superType()

let instance = new subType()
instance.getSuperVal() === true
```

![image-20200727215744042](/Users/hxy_nuc/Library/Application Support/typora-user-images/image-20200727215744042.png)

确定实例和原型的关系

- instaceof：实例 instanceof 原型
- isPrototypeOf：原型.isPrototypeOf(实例)

注意点

- 重写方法时，必须在连接原型链之后，否则会影响父类方法
- 不能使用字面量方式在子类原型上添加新方法，会导致原型链被切断

#### 借用构造函数

主要用于解决引用类型的属性带来的问题且可以在实例化子类时传递参数

```javascript
function superType(age){
  this.color = ['red', 'blue', 'green']
  this.age = age
}
function subType(){
  // 调用父类构造函数，this指向子类，即把相关属性都在子类上重新创建一份
  // arg即为要给父类传递的参数，还可以在下面直接定义子类的实例属性
  superType.call(this, arg)
}
// new subType()生成的两个实例会相互无影响
```

#### 组合继承

组合原型链和借用构造函数的继承：通过构造函数继承属性和传参，通过原型链继承方法

```javascript
function superType(name){
  this.name = name
  this.color = ['r', 'g', 'b']
}
superType.prototype.sayName = function(){ alert(this.name) }

function subType(name, age){
  // 借用构造函数来继承属性和传参
  superType.call(this, name)  // 第2次执行父类构造函数
  this.age = age
}

// 原型链来继承方法
subType.prototype = new superType()  // 第1次执行父类构造函数
subType.prototype.sayAge = function() { alert(this.age) }
```

#### 原型式继承

```javascript
// 将原型链继承进行封装，先创建一个临时性的构造函数，然后将传入的对象作为该构造函数的原型
// 该方式即Object.create()，与原型链继承区别只是创建一个空子类出来
function createObj(o){
  function F() {} //临时类
  F.prototype = o //将临时类的原型指向o
  return new F()
}
```

Object.create() 第一个参数为新对象的原型，即新创建对象的`__proto__`指向该参数，第二个参数为新对象定义额外属性的对象

#### 寄生继承

```javascript
// 寄生继承是依托于一个对象而生的一种继承方式
function createAnthor(origin){
  let clone = Object.create(origin)
  clone.sayHi = function() { alert('hi') }
  return clone
}
```

#### 寄生组合式继承

组合继承调用了两次父类构造函数，第二次借用构造函数时又创建了实例自身的属性，屏蔽了原型链上属性

在将子类型实例绑定到父类时，可以不需要调用父类构造函数

```javascript
// 寄生组合式继承的核心方法，以父类原型来创建对象，这样可以减少一次父类构造函数调用
function inherit(subT, superT){
  let pro = Object.create(superT.prototype) // 创建父类原型副本
  subT.prototype = pro // 继承父类原型
  pro.constructor = subT // 将子类原型的constructor指向自身
}
// 正常组合继承
function superT(name) {
    this.name = name
    this.color = ['r', 'g', 'b']
}
superT.prototype.sayName = function () {
    console.log(this.name)
}

function subT(name, age) {
    superT.call(this, name)
    this.age = age
}
//继承原型链时调用封装的方法
inherit(subT, superT)

subT.prototype.sayAge = function () {
    console.log(this.age)
}
```

#### 几种继承方式对比

| 继承方式         | 优缺点                                                       |
| ---------------- | ------------------------------------------------------------ |
| 原型链继承       | 属性会在子类实例上共享，引用类型的属性则会相互影响； 创建子类实例时，无法向父类的构造函数传递参数 |
| 借用构造函数模式 | 解决了引用类型及向父类构造函数传参问题，但方法无复用         |
| 组合继承         | 父类构造函数被调用了两次，子类实例constructor指向父类        |
| 原型式继承       | 同原型链继承                                                 |
| 寄生式继承       | 继承一个单例对象的场景实在是太少                             |
| 寄生组合式继承   | 不存在属性共享，可以给父类传参，父类构造函数只调用一次       |

---

### 原型链补充：实例、构造函数、原型对象关系

```javascript
function F(){}
var f = new F();
// 构造器
F.prototype.constructor === F; // true
F.__proto__ === Function.prototype; // true
Function.prototype.__proto__ === Object.prototype; // true
Object.prototype.__proto__ === null; // true

// 实例
f.__proto__ === F.prototype; // true
F.prototype.__proto__ === Object.prototype; // true
Object.prototype.__proto__ === null; // true
```

![image-20200728164627841](/Users/hxy_nuc/Library/Application Support/typora-user-images/image-20200728164627841.png)

完整版

![image-20200728201646253](/Users/hxy_nuc/Library/Application Support/typora-user-images/image-20200728201646253.png)

---

### ES6 Class extends继承

![image-20200728194723658](/Users/hxy_nuc/Library/Application Support/typora-user-images/image-20200728194723658.png)

#### ES6 extends的ES5实现

几乎就是寄生组合式继承，加上子类的构造函数`__proto__`指向父类构造函数

```javascript
function _inherits(Child, Parent){
    Child.prototype = Object.create(Parent.prototype);  // 创建父类原型副本、且继承
    Child.prototype.constructor = Child; // 将子类原型构造函数指向自身
    // __proto__  增加的一步，即上图左边橙色的线
    Child.__proto__ = Parent;
}
// 借用构造函数时就相当于super
```

---



